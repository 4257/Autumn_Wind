## C++
### 类和对象
将结构体直接做为参数传递的时候，传递的是整个结构体  
一般建议使用结构体指针来传递  
* 将函数定义到结构体内部，就是封装			
* 编译器会自动传递结构体的指针给函数  
```C++
struct myStruct{
	int x;
	int y;

	void(){
		return x+y;
	}
}
main(){

	void();//lea ecx,[ebp-8h]	
	return 0;
}
```			
### 类  	
带有函数的结构体 称为类	
### 成员函数  
结构体里面的函数 称为成员函数
空结构体和只有成员函数的结构体大小为1  
### 对象：
结构体类型声明的变量就是对象
### this指针
用或者不用，它就在那里  
参数个数确定的时候，用ecx来传递  
参数个数不确定的时候，最后一个传递(不定长参数)  
this指针不能做++ -- 等运算，不能重新被赋值  
this指针不占用结构体的宽度  
**当成员函数的参数和成员变量同名的时候 可以显式的使用this指针**
```C++
struct sclass				
{				
	int a;			
	int b;			
				
	void Init(int a,int b)			
	{			
		this->a = a;		
		this->b = b;		
	}			
	void Print()			
	{			
		printf("%d %d",a,b);		
	}					
};	
```
### 构造函数
与类同名  
没有返回值  
创建对象的时候执行  
主要用于初始化  
可以有多个 最好有一个无参构造函数  
编译器不要求必须提供  
类创建的时候会默认生成一个无参构造函数  
子类生成对象的时候会先调用父类的构造函数 再调用子类的构造函数  
### 析构函数  
编译器自动提供
只能有一个析构函数  
不能带参数和返回值  
主要用于在堆中申请的内存的清理工作  
编译器不要求必须提供  
### 继承
继承就是数据的复制  
减少重复代码的编写  
父类的指针可以指向子类的对象  
子类的指针不可以指向父类的对象（编译器角度）  
依据另一个类（基类/父类）来定义一个类（派生类/子类）  
可以从多个基类继承  
```C++
class derived-class: access-specifier base-class
```
```C++
derived-class #派生类
access-specifier #访问修饰符（public、protected、private ）
base-class #基类
```
### 继承的访问控制
派生类可以访问基类中所有的非私有成员 基类也可以将不想被派生类访问的成员设为私有（private）  

访问|public|protected|private
--|--|--|--|
同一个类|yes|yes|yes
派生类|yes|yes|no
外部的类|yes|no|no  

派生类继承了基类中的所有基类方法，但下列除外  
基类的构造函数、析构函数、和拷贝构造函数  
基类的重载运算符  
基类的友元函数  
### 函数重载（override）
在同一个作用域中，可以声明一些功能类似的同名函数，但是函数的形式参数（指参数的个数、类型和顺序）必须不同 不能仅通过返回类型的不同来重载函数
### 运算符重载
Box operator+(const Box&);
### 多态
多态存在与类之间的层级结构，并且类之间是通过继承关联时  
C++的多态意为着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数  


